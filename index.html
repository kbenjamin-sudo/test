<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>StudyOS</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">

<style>
:root{
  --bg:#0a0c11;
  --bg2:#0c0f16;
  --surface:rgba(255,255,255,.04);
  --surface2:rgba(255,255,255,.055);
  --border:rgba(255,255,255,.10);
  --border2:rgba(255,255,255,.14);
  --text:#f4f6fb;
  --muted:#a7afc2;
  --muted2:#7f879b;
  --accent:#4f8cff;
  --accent2:#8ab7ff;
  --bad:#ff4d4d;
  --good:#41d98a;
  --shadow: 0 18px 40px rgba(0,0,0,.40);
  --radius:18px;
  --radius2:22px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family:"Montserrat",sans-serif;
  background:
    radial-gradient(1200px 900px at 15% -10%, rgba(79,140,255,.18), transparent 55%),
    radial-gradient(1000px 800px at 90% 0%, rgba(138,183,255,.11), transparent 55%),
    linear-gradient(180deg, var(--bg2), var(--bg));
  color:var(--text);
  overflow:hidden;
}
button,input,select,textarea{font:inherit}
button{cursor:pointer}
a{color:inherit}
.hidden{display:none!important}

#app{
  height:100dvh;
  height:100vh;
  display:flex;
  flex-direction:column;
  padding:14px;
  gap:12px;
}

.shell{
  flex:1;
  min-height:0;
  display:flex;
  gap:12px;
}

.topbar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  background:rgba(255,255,255,.035);
  border:1px solid rgba(255,255,255,.08);
  border-radius:var(--radius2);
  padding:12px 14px;
  box-shadow: var(--shadow);
}
.brand{display:flex;align-items:center;gap:12px;min-width:0}
.logo{
  width:40px;height:40px;border-radius:14px;
  background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.35), transparent 35%),
              linear-gradient(135deg, rgba(79,140,255,1), rgba(138,183,255,1));
  box-shadow: 0 14px 30px rgba(79,140,255,.18);
  flex:0 0 auto;
}
.brandtxt{min-width:0}
.brand h1{
  margin:0;
  font-size:14px;
  letter-spacing:.5px;
  font-weight:700;
}
.mini{font-size:12px;color:var(--muted)}
.row{display:flex;gap:10px;align-items:center;flex:0 0 auto}

.pill{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:8px 10px;
  border-radius:999px;
  background:rgba(0,0,0,.22);
  border:1px solid rgba(255,255,255,.09);
}
.btn{
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.06);
  color:var(--text);
  padding:10px 12px;
  border-radius:14px;
  transition:transform .08s ease, border-color .12s ease, background .12s ease, opacity .12s ease;
}
.btn:hover{border-color: rgba(255,255,255,.18); background:rgba(255,255,255,.075)}
.btn:active{transform:translateY(1px)}
.btn.primary{
  background: linear-gradient(135deg, rgba(79,140,255,1), rgba(138,183,255,1));
  color:#0a0c11;
  border:0;
}
.btn.danger{
  background: rgba(255,77,77,.12);
  border-color: rgba(255,77,77,.25);
  color:#ffd2d2;
}
.btn.ghost{background:transparent}
.btn:disabled{opacity:.55;cursor:not-allowed}

.sidebar{
  width:280px;min-width:240px;
  background:rgba(255,255,255,.035);
  border:1px solid rgba(255,255,255,.08);
  border-radius:var(--radius2);
  box-shadow: var(--shadow);
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:10px;
  min-height:0;
}
.navGroupTitle{
  font-size:11px;
  color:var(--muted2);
  text-transform:uppercase;
  letter-spacing:.14em;
  margin:2px 8px 0;
}
.navbtn{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  width:100%;
  padding:12px 12px;
  border-radius:16px;
  background:transparent;
  border:1px solid transparent;
  color:var(--text);
  text-align:left;
}
.navbtn:hover{
  background:rgba(255,255,255,.05);
  border-color:rgba(255,255,255,.08);
}
.navbtn.active{
  background:rgba(79,140,255,.14);
  border-color:rgba(79,140,255,.28);
}
.badge{
  font-size:12px;
  padding:3px 9px;
  border-radius:999px;
  background:rgba(0,0,0,.22);
  border:1px solid rgba(255,255,255,.10);
  color:var(--muted);
}
.kbd{
  font-size:12px;
  padding:2px 7px;
  border-radius:9px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.20);
  color:var(--muted);
}
.hr{height:1px;background:rgba(255,255,255,.08);margin:10px 0}

.main{
  flex:1;
  min-width:0;
  min-height:0;
  background:rgba(255,255,255,.035);
  border:1px solid rgba(255,255,255,.08);
  border-radius:var(--radius2);
  box-shadow: var(--shadow);
  overflow:hidden;
  display:flex;
  flex-direction:column;
}
.cardhead{
  padding:12px 12px 10px;
  border-bottom:1px solid rgba(255,255,255,.08);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  background:linear-gradient(180deg, rgba(255,255,255,.02), transparent);
}
.cardhead h2{
  margin:0;
  font-size:13px;
  letter-spacing:.4px;
  font-weight:700;
}
.content{flex:1;min-height:0;overflow:auto;padding:12px}

.inline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.splitbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:space-between}

.grid2{
  display:grid;
  grid-template-columns: 360px 1fr;
  gap:12px;
  min-height:0;
}
@media (max-width: 980px){
  body{overflow:auto}
  #app{height:auto;min-height:100dvh}
  .shell{flex-direction:column}
  .sidebar{width:auto}
  .grid2{grid-template-columns:1fr}
}

.field{display:flex;flex-direction:column;gap:6px}
label{font-size:12px;color:var(--muted)}
input[type="text"],input[type="email"],input[type="password"],select,textarea{
  width:100%;
  background:rgba(0,0,0,.24);
  border:1px solid rgba(255,255,255,.10);
  color:var(--text);
  border-radius:14px;
  padding:11px 12px;
  outline:none;
}
select{appearance:none}
textarea{resize:none;min-height:260px;line-height:1.55}
input:focus,select:focus,textarea:focus{
  border-color: rgba(79,140,255,.45);
  box-shadow: 0 0 0 3px rgba(79,140,255,.18);
}

.list{display:flex;flex-direction:column;gap:8px}
.noteitem{
  text-align:left;
  width:100%;
  padding:12px 12px;
  border-radius:16px;
  background:rgba(0,0,0,.18);
  border:1px solid rgba(255,255,255,.10);
}
.noteitem:hover{border-color:rgba(255,255,255,.16); background:rgba(0,0,0,.22)}
.noteitem.active{
  background:rgba(79,140,255,.14);
  border-color:rgba(79,140,255,.28);
}
.noteitem b{display:block;font-size:13px; font-weight:700}
.noteitem small{display:block;color:var(--muted);margin-top:2px;font-size:12px;line-height:1.35}

.canvasWrap{
  width:100%;
  height:520px;
  border-radius:20px;
  background:rgba(0,0,0,.22);
  border:1px solid rgba(255,255,255,.10);
  overflow:hidden;
}
.canvasWrap canvas{width:100%;height:100%}

.gameRow{display:grid;grid-template-columns: 1fr 340px;gap:12px}
@media (max-width: 980px){.gameRow{grid-template-columns:1fr}}
.panel{
  background:rgba(0,0,0,.20);
  border:1px solid rgba(255,255,255,.10);
  border-radius:20px;
  padding:12px;
}
.panel h3{margin:0 0 10px;font-size:13px;font-weight:700;letter-spacing:.2px}
.smallbtn{
  padding:9px 11px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.06);
  color:var(--text);
  transition:transform .08s ease, border-color .12s ease, background .12s ease;
}
.smallbtn:hover{border-color: rgba(255,255,255,.18); background:rgba(255,255,255,.075)}
.smallbtn:active{transform:translateY(1px)}
.smallbtn.primary{
  background:rgba(79,140,255,.16);
  border-color:rgba(79,140,255,.28);
}

.switch{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:11px 11px;
  border:1px solid rgba(255,255,255,.10);
  border-radius:16px;
  background:rgba(0,0,0,.18);
}
.switch b{font-size:12px;font-weight:700}
.switch small{color:var(--muted);font-size:12px}

.touchControls{
  display:none;
  gap:8px;
  flex-wrap:wrap;
  margin-top:10px;
}
.touchControls .smallbtn{flex:1;min-width:90px}
@media (max-width: 980px){
  .touchControls{display:flex}
}

.toast{
  position:fixed;
  left:50%;
  bottom:18px;
  transform:translateX(-50%);
  padding:10px 12px;
  border-radius:16px;
  background:rgba(0,0,0,.78);
  border:1px solid rgba(255,255,255,.10);
  color:var(--text);
  box-shadow: var(--shadow);
  max-width:min(640px, calc(100% - 24px));
  display:none;
}
.toast.show{display:block}

.modalOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.65);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:14px;
  z-index:50;
}
.modal{
  width:min(520px,100%);
  background:rgba(12,14,18,.96);
  border:1px solid rgba(255,255,255,.10);
  border-radius:20px;
  box-shadow: var(--shadow);
  padding:14px;
}
.modalTitle{font-weight:700}
</style>
</head>

<body>
<div id="app">
  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div class="brandtxt">
        <h1>StudyOS</h1>
        <div class="mini" id="statusLine">Offline demo</div>
      </div>
    </div>
    <div class="row">
      <div class="pill">
        <small id="authText">Not signed in</small>
      </div>
      <button class="btn" id="btnOpenAuth">Sign in</button>
      <button class="btn ghost hidden" id="btnLogout">Log out</button>
    </div>
  </div>

  <div class="shell">
    <div class="sidebar">
      <div class="navGroupTitle">Workspace</div>
      <button class="navbtn active" data-tab="notes"><span>Notes</span><span class="badge" id="notesCount">0</span></button>
      <button class="navbtn" data-tab="graph"><span>Graph</span><span class="badge">links</span></button>

      <div class="navGroupTitle" style="margin-top:6px">Focus</div>
      <button class="navbtn" data-tab="games"><span>Games</span><span class="badge">2</span></button>
      <button class="navbtn" data-tab="timer"><span>Timer</span><span class="badge">focus</span></button>
      <button class="navbtn" data-tab="settings"><span>Settings</span><span class="badge">prefs</span></button>

      <div class="hr"></div>
      <div class="mini">Quick mute: <span class="kbd">`</span></div>
      <div class="mini">Quick new note: <span class="kbd">N</span></div>
    </div>

    <div class="main">
      <div class="cardhead">
        <h2 id="panelTitle">Notes</h2>
        <div class="inline">
          <span class="mini" id="saveState">—</span>
          <button class="btn primary" id="btnNewNote">New</button>
        </div>
      </div>

      <div class="content">
        <section id="tab-notes">
          <div class="grid2">
            <div>
              <div class="field">
                <label>Search</label>
                <input id="noteSearch" type="text" placeholder="Find a note...">
              </div>

              <div class="inline" style="margin-top:10px">
                <div class="field" style="flex:1;min-width:160px">
                  <label>School</label>
                  <select id="filterSchool">
                    <option value="">All</option>
                    <option>Salesianum</option>
                    <option>St Peter</option>
                    <option>McKean</option>
                    <option>Other</option>
                  </select>
                </div>
                <div class="field" style="flex:1;min-width:160px">
                  <label>Category</label>
                  <select id="filterCategory">
                    <option value="">All</option>
                    <option>Math</option>
                    <option>English</option>
                    <option>Science</option>
                    <option>History</option>
                    <option>Language</option>
                    <option>Other</option>
                  </select>
                </div>
              </div>

              <div class="hr"></div>
              <div class="list" id="notesList"></div>
            </div>

            <div>
              <div class="inline">
                <button class="btn" id="btnSaveNow">Save</button>
                <button class="btn" id="btnPrint">Print/PDF</button>
                <button class="btn" id="btnLink">Link</button>
                <button class="btn danger" id="btnDelete">Delete</button>
              </div>

              <div class="hr"></div>

              <div class="inline">
                <div class="field" style="flex:1;min-width:240px">
                  <label>Title</label>
                  <input id="noteTitle" type="text" placeholder="Title">
                </div>
                <div class="field" style="min-width:170px">
                  <label>School</label>
                  <select id="noteSchool">
                    <option>Salesianum</option>
                    <option>St Peter</option>
                    <option>McKean</option>
                    <option>Other</option>
                  </select>
                </div>
              </div>

              <div class="inline" style="margin-top:10px">
                <div class="field" style="min-width:170px">
                  <label>Category</label>
                  <select id="noteCategory">
                    <option>Math</option>
                    <option>English</option>
                    <option>Science</option>
                    <option>History</option>
                    <option>Language</option>
                    <option>Other</option>
                  </select>
                </div>
                <div class="field" style="min-width:170px">
                  <label>Grade</label>
                  <select id="noteGrade">
                    <option value="">—</option>
                    <option>7</option><option>8</option><option>9</option><option>10</option><option>11</option><option>12</option>
                  </select>
                </div>
                <div class="field" style="flex:1;min-width:240px">
                  <label>Tags (comma separated)</label>
                  <input id="noteTags" type="text" placeholder="algebra, test, unit 2">
                </div>
              </div>

              <div class="field" style="margin-top:10px">
                <label>Content</label>
                <textarea id="noteContent" placeholder="Write here..."></textarea>
              </div>

              <div class="mini" style="margin-top:8px" id="noteMeta">—</div>
            </div>
          </div>
        </section>

        <section id="tab-graph" class="hidden">
          <div class="splitbar">
            <div class="mini">Drag nodes. Scroll to zoom. Click a node to open.</div>
            <button class="btn" id="btnReloadGraph">Reload</button>
          </div>
          <div class="hr"></div>
          <div class="canvasWrap"><canvas id="graphCanvas"></canvas></div>
        </section>

        <section id="tab-games" class="hidden">
          <div class="gameRow">
            <div class="panel">
              <div class="inline" style="justify-content:space-between">
                <h3 id="gameTitle">Snake</h3>
                <div class="inline">
                  <button class="smallbtn" id="btnGameSnake">Snake</button>
                  <button class="smallbtn" id="btnGameTetris">Tetris</button>
                </div>
              </div>
              <div class="hr"></div>
              <div class="canvasWrap" style="height:520px"><canvas id="gameCanvas"></canvas></div>
              <div class="hr"></div>

              <div class="inline" style="justify-content:space-between">
                <div class="mini" id="gameHint">Arrow keys / WASD. Tap to turn. Space to restart.</div>
                <div class="inline">
                  <button class="smallbtn primary" id="btnGameStart">Start</button>
                  <button class="smallbtn" id="btnGameReset">Reset</button>
                </div>
              </div>

              <div class="touchControls" id="touchControls">
                <button class="smallbtn" id="touchLeft">Left</button>
                <button class="smallbtn" id="touchRotate">Rotate</button>
                <button class="smallbtn" id="touchRight">Right</button>
                <button class="smallbtn" id="touchDown">Down</button>
                <button class="smallbtn primary" id="touchDrop">Drop</button>
              </div>
            </div>

            <div class="panel">
              <h3>Game settings</h3>

              <div class="switch">
                <div><b>Sound effects</b><small>Small beeps only</small></div>
                <input id="sfxEnabled" type="checkbox" checked>
              </div>

              <div id="snakeSettings" style="margin-top:10px">
                <div class="switch">
                  <div><b>Snake hard mode</b><small>Faster + obstacles</small></div>
                  <input id="snakeHard" type="checkbox" checked>
                </div>

                <div class="hr"></div>
                <h3 style="margin:0 0 10px;font-size:13px;font-weight:700">Snake boosts</h3>

                <div class="switch">
                  <div><b>Wrap walls</b><small>Teleport through edges</small></div>
                  <input id="cheatWrap" type="checkbox">
                </div>
                <div class="switch" style="margin-top:10px">
                  <div><b>Slow time</b><small>Chill speed</small></div>
                  <input id="cheatSlow" type="checkbox">
                </div>
                <div class="switch" style="margin-top:10px">
                  <div><b>Magnet food</b><small>Food drifts to you</small></div>
                  <input id="cheatMagnet" type="checkbox">
                </div>
                <div class="switch" style="margin-top:10px">
                  <div><b>Invincible (10s)</b><small>Press to activate</small></div>
                  <button class="smallbtn" id="btnInvincible">Activate</button>
                </div>

                <div class="inline" style="margin-top:10px">
                  <button class="smallbtn" id="btnAdd5">+5 length</button>
                  <button class="smallbtn" id="btnClearObs">Clear obstacles</button>
                </div>
              </div>

              <div id="tetrisSettings" class="hidden" style="margin-top:10px">
                <div class="switch">
                  <div><b>Ghost piece</b><small>Show landing preview</small></div>
                  <input id="tetrisGhost" type="checkbox" checked>
                </div>
                <div class="switch" style="margin-top:10px">
                  <div><b>Lock delay</b><small>More forgiving placement</small></div>
                  <input id="tetrisLock" type="checkbox" checked>
                </div>
              </div>

              <div class="hr"></div>
              <div class="mini" id="gameStats">—</div>
            </div>
          </div>
        </section>

        <section id="tab-timer" class="hidden">
          <div class="inline" style="justify-content:space-between">
            <div>
              <div style="font-size:40px;font-weight:700" id="timerDisplay">25:00</div>
              <div class="mini" id="timerState">Ready</div>
            </div>
            <div class="inline">
              <button class="btn primary" id="btnTimerStart">Start</button>
              <button class="btn" id="btnTimerPause">Pause</button>
              <button class="btn" id="btnTimerReset">Reset</button>
            </div>
          </div>
          <div class="hr"></div>
          <div class="inline">
            <div class="field" style="min-width:180px">
              <label>Focus minutes</label>
              <input id="focusMins" type="text" value="25">
            </div>
            <div class="field" style="min-width:180px">
              <label>Break minutes</label>
              <input id="breakMins" type="text" value="5">
            </div>
          </div>
        </section>

        <section id="tab-settings" class="hidden">
          <div class="grid2" style="grid-template-columns: 1fr 1fr">
            <div>
              <h3 style="margin:0 0 8px;font-size:13px;font-weight:700">Defaults</h3>
              <div class="field">
                <label>Default school</label>
                <select id="defaultSchool">
                  <option>Salesianum</option>
                  <option>St Peter</option>
                  <option>McKean</option>
                  <option>Other</option>
                </select>
              </div>
              <div class="field" style="margin-top:10px">
                <label>Default category</label>
                <select id="defaultCategory">
                  <option>Math</option>
                  <option>English</option>
                  <option>Science</option>
                  <option>History</option>
                  <option>Language</option>
                  <option>Other</option>
                </select>
              </div>
              <div class="hr"></div>
              <div class="mini" id="settingsSaveState">—</div>
              <button class="btn" id="btnSaveSettings">Save settings</button>
            </div>

            <div>
              <h3 style="margin:0 0 8px;font-size:13px;font-weight:700">Nerd audio</h3>
              <div class="mini" style="margin-bottom:10px">Password required (local only). Audio will not autoplay.</div>

              <div class="inline">
                <input id="nerdPass" type="password" placeholder="Password">
                <button class="btn primary" id="nerdUnlock">Unlock</button>
              </div>

              <div id="nerdPanel" class="hidden" style="margin-top:12px">
                <div class="switch">
                  <div><b>Remember unlock</b><small>On this device only</small></div>
                  <input id="rememberUnlock" type="checkbox">
                </div>

                <div class="hr"></div>

                <div class="field">
                  <label>Track</label>
                  <select id="trackSelect"></select>
                </div>

                <div class="inline" style="margin-top:10px">
                  <button class="btn primary" id="btnPlayPause">Play</button>
                  <button class="btn" id="btnStop">Stop</button>
                </div>

                <div class="field" style="margin-top:10px">
                  <label>Volume</label>
                  <input id="musicVol" type="text" value="0.25">
                </div>

                <div class="mini" style="margin-top:10px">Quick mute key: <span class="kbd">`</span></div>
                <audio id="bgAudio" preload="none" class="hidden"></audio>
              </div>
            </div>
          </div>
        </section>

      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<div id="authModal" class="modalOverlay hidden">
  <div class="modal">
    <div class="inline" style="justify-content:space-between">
      <div>
        <div class="modalTitle">Account</div>
        <div class="mini">Supabase email + password</div>
      </div>
      <button class="btn" id="btnCloseAuth">Close</button>
    </div>
    <div class="hr"></div>
    <div class="grid2" style="grid-template-columns:1fr 1fr;gap:10px">
      <div class="field" style="grid-column:1/-1">
        <label>Email</label>
        <input id="authEmail" type="email" placeholder="you@example.com">
      </div>
      <div class="field" style="grid-column:1/-1">
        <label>Password</label>
        <input id="authPass" type="password" placeholder="••••••••">
      </div>
      <button class="btn primary" id="btnSignIn">Sign in</button>
      <button class="btn" id="btnSignUp">Sign up</button>
    </div>
    <div class="mini" style="margin-top:10px" id="authMsg">—</div>
  </div>
</div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

const SUPABASE_URL = "https://cgmazcvmpcgistoimqlw.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNnbWF6Y3ZtcGNnaXN0b2ltcWx3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAyMjI2NjMsImV4cCI6MjA4NTc5ODY2M30.iIoIyb4bBnOR1zEjZ6ORpLsfJX77YWM1LyYoo_NrUuc";

const sb = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true }
});

const el = (id) => document.getElementById(id);
const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));

let toastTimer = null;
function toast(msg){
  const t = el("toast");
  if(!t) return;
  t.textContent = msg;
  t.classList.add("show");
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>t.classList.remove("show"), 2200);
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
}

function fmtTime(ts){
  try{
    const d = new Date(ts);
    return d.toLocaleString([], { month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
  }catch(_){ return ""; }
}

function setStatus(line){
  const s = el("statusLine");
  if(s) s.textContent = line;
}

function setSaveState(t){
  const s = el("saveState");
  if(s) s.textContent = t;
}

const APP = {
  user: null,
  notes: [],
  activeNote: null,
  links: [],
  saveDebounce: null,
  settings: { defaults: { school:"Salesianum", category:"Math" }, nerd: { track:0, vol:0.25, remember:false } },
  sfxOn: true,
  audioUnlocked: false,
  invincibleUntil: 0
};

function requireUser(){
  if(!APP.user){
    toast("Sign in to save.");
    return false;
  }
  return true;
}

function setAuthedUI(){
  const authText = el("authText");
  const btnOpenAuth = el("btnOpenAuth");
  const btnLogout = el("btnLogout");
  if(APP.user){
    if(authText) authText.textContent = APP.user.email || "Signed in";
    if(btnOpenAuth) btnOpenAuth.classList.add("hidden");
    if(btnLogout) btnLogout.classList.remove("hidden");
    setStatus("Online");
  }else{
    if(authText) authText.textContent = "Not signed in";
    if(btnOpenAuth) btnOpenAuth.classList.remove("hidden");
    if(btnLogout) btnLogout.classList.add("hidden");
    setStatus("Offline demo");
  }
}

async function ensureSettingsRow(){
  if(!APP.user) return;
  const payload = {
    user_id: APP.user.id,
    current_school: APP.settings.defaults.school,
    ui: { defaults: { school: APP.settings.defaults.school, category: APP.settings.defaults.category } },
    nerd: { track: APP.settings.nerd.track, vol: APP.settings.nerd.vol }
  };
  await sb.from("user_settings").upsert(payload, { onConflict: "user_id" });
}

async function loadSettings(){
  if(!APP.user) return;
  const { data } = await sb.from("user_settings").select("*").eq("user_id", APP.user.id).maybeSingle();
  if(!data) return;

  const defaults = (data.ui && data.ui.defaults) ? data.ui.defaults : null;
  APP.settings.defaults.school = defaults?.school || data.current_school || "Salesianum";
  APP.settings.defaults.category = defaults?.category || "Math";

  const nerd = data.nerd || {};
  APP.settings.nerd.track = Number.isFinite(nerd.track) ? nerd.track : 0;
  APP.settings.nerd.vol = Number.isFinite(nerd.vol) ? nerd.vol : 0.25;

  const ds = el("defaultSchool");
  const dc = el("defaultCategory");
  if(ds) ds.value = APP.settings.defaults.school;
  if(dc) dc.value = APP.settings.defaults.category;

  const ns = el("noteSchool");
  const nc = el("noteCategory");
  if(ns) ns.value = APP.settings.defaults.school;
  if(nc) nc.value = APP.settings.defaults.category;

  const v = el("musicVol");
  if(v) v.value = String(APP.settings.nerd.vol);
}

async function saveSettings(){
  if(!requireUser()) return;
  APP.settings.defaults.school = el("defaultSchool")?.value || "Salesianum";
  APP.settings.defaults.category = el("defaultCategory")?.value || "Math";

  const payload = {
    user_id: APP.user.id,
    current_school: APP.settings.defaults.school,
    ui: { defaults: { school: APP.settings.defaults.school, category: APP.settings.defaults.category } },
    nerd: { track: APP.settings.nerd.track, vol: APP.settings.nerd.vol }
  };
  const { error } = await sb.from("user_settings").upsert(payload, { onConflict: "user_id" });
  const s = el("settingsSaveState");
  if(error){
    if(s) s.textContent = "Save failed";
    toast("Settings save failed");
    return;
  }
  if(s) s.textContent = "Saved";
  toast("Saved settings");
}

function setEditorEnabled(on){
  const ids = ["btnSaveNow","btnPrint","btnLink","btnDelete","noteTitle","noteSchool","noteCategory","noteGrade","noteTags","noteContent"];
  for(const id of ids){
    const x = el(id);
    if(x) x.disabled = !on;
  }
}

function fillEditor(note){
  APP.activeNote = note;

  if(el("noteTitle")) el("noteTitle").value = note?.title ?? "";
  if(el("noteSchool")) el("noteSchool").value = note?.school || APP.settings.defaults.school;
  if(el("noteCategory")) el("noteCategory").value = note?.category || APP.settings.defaults.category;
  if(el("noteGrade")) el("noteGrade").value = note?.grade ?? "";
  if(el("noteTags")) el("noteTags").value = (note?.tags || []).join(", ");
  if(el("noteContent")) el("noteContent").value = note?.content ?? "";

  const meta = el("noteMeta");
  if(meta){
    const parts = [];
    if(note?.created_at) parts.push("Created " + fmtTime(note.created_at));
    if(note?.updated_at) parts.push("Updated " + fmtTime(note.updated_at));
    meta.textContent = parts.length ? parts.join(" • ") : "—";
  }

  setEditorEnabled(!!note);
  renderNotesList();
}

function editorToPayload(){
  const title = el("noteTitle")?.value ?? "";
  const school = el("noteSchool")?.value ?? APP.settings.defaults.school;
  const category = el("noteCategory")?.value ?? APP.settings.defaults.category;
  const grade = el("noteGrade")?.value ?? "";
  const tagsRaw = el("noteTags")?.value ?? "";
  const tags = tagsRaw.split(",").map(s=>s.trim()).filter(Boolean).slice(0, 30);
  const content = el("noteContent")?.value ?? "";
  return { title, school, category, grade, tags, content };
}

function renderNotesList(){
  const list = el("notesList");
  if(!list) return;
  list.innerHTML = "";

  const q = (el("noteSearch")?.value || "").trim().toLowerCase();
  const fs = el("filterSchool")?.value || "";
  const fc = el("filterCategory")?.value || "";

  const filtered = APP.notes.filter(n=>{
    const t = (n.title || "").toLowerCase();
    const c = (n.content || "").toLowerCase();
    const okQ = !q || t.includes(q) || c.includes(q);
    const okS = !fs || (n.school || "") === fs;
    const okC = !fc || (n.category || "") === fc;
    return okQ && okS && okC;
  }).sort((a,b)=> new Date(b.updated_at) - new Date(a.updated_at));

  if(el("notesCount")) el("notesCount").textContent = String(filtered.length);

  if(filtered.length === 0){
    const div = document.createElement("div");
    div.className = "mini";
    div.textContent = APP.user ? "No notes yet. Hit New." : "Sign in to save notes.";
    list.appendChild(div);
    return;
  }

  for(const n of filtered){
    const b = document.createElement("button");
    b.className = "noteitem" + (APP.activeNote && APP.activeNote.id === n.id ? " active" : "");
    const title = (n.title || "").trim() || "(untitled)";
    const meta = `${n.school || ""}${n.category ? " • " + n.category : ""}${n.grade ? " • grade " + n.grade : ""}`;
    b.innerHTML = `<b>${escapeHtml(title)}</b><small>${escapeHtml(meta)} • ${escapeHtml(fmtTime(n.updated_at))}</small>`;
    b.addEventListener("click", ()=> openNote(n.id));
    list.appendChild(b);
  }
}

async function fetchNotes(){
  if(!APP.user){
    APP.notes = [];
    fillEditor(null);
    renderNotesList();
    return;
  }
  setSaveState("Loading...");
  const { data, error } = await sb.from("notes")
    .select("id,title,content,school,category,grade,tags,created_at,updated_at")
    .order("updated_at", { ascending:false })
    .limit(250);

  if(error){
    setSaveState("Load failed");
    toast("Notes load failed");
    return;
  }
  APP.notes = data || [];
  setSaveState("Ready");
  renderNotesList();
  if(!APP.activeNote && APP.notes.length) await openNote(APP.notes[0].id);
  if(!APP.notes.length) fillEditor(null);
}

async function openNote(id){
  if(!APP.user){
    toast("Sign in to open notes.");
    return;
  }
  setSaveState("Loading note...");
  const { data, error } = await sb.from("notes").select("*").eq("id", id).single();
  if(error){
    setSaveState("Open failed");
    toast("Open failed");
    return;
  }
  fillEditor(data);
  setSaveState("Ready");
}

async function createNote(){
  if(!requireUser()) return;
  setSaveState("Creating...");
  const payload = {
    user_id: APP.user.id,
    title:"",
    content:"",
    school: APP.settings.defaults.school,
    category: APP.settings.defaults.category,
    grade:"",
    tags:[]
  };
  const { data, error } = await sb.from("notes").insert(payload).select("*").single();
  if(error){
    setSaveState("Create failed");
    toast("Create failed");
    return;
  }
  APP.notes.unshift(data);
  fillEditor(data);
  setSaveState("Ready");
  toast("New note");
}

async function deleteNote(){
  if(!requireUser()) return;
  if(!APP.activeNote) return;
  const id = APP.activeNote.id;
  setSaveState("Deleting...");
  const { error } = await sb.from("notes").delete().eq("id", id);
  if(error){
    setSaveState("Delete failed");
    toast("Delete failed");
    return;
  }
  APP.notes = APP.notes.filter(n=>n.id !== id);
  fillEditor(null);
  renderNotesList();
  setSaveState("Ready");
  toast("Deleted");
}

async function saveNow(){
  if(!requireUser()) return;
  if(!APP.activeNote) return;
  const id = APP.activeNote.id;
  setSaveState("Saving...");
  const patch = editorToPayload();
  const { data, error } = await sb.from("notes").update(patch).eq("id", id).select("*").single();
  if(error){
    setSaveState("Save failed");
    toast("Save failed");
    return;
  }
  APP.activeNote = data;
  const idx = APP.notes.findIndex(n=>n.id===id);
  if(idx>=0) APP.notes[idx]=data;
  fillEditor(data);
  setSaveState("Saved");
}

function scheduleAutosave(){
  clearTimeout(APP.saveDebounce);
  APP.saveDebounce = setTimeout(()=>saveNow(), 600);
}

function printActive(){
  if(!APP.activeNote){
    toast("Open a note first");
    return;
  }
  const note = { ...APP.activeNote, ...editorToPayload() };
  const w = window.open("", "_blank", "noopener,noreferrer");
  if(!w){
    toast("Popup blocked");
    return;
  }
  const safeTitle = escapeHtml(note.title || "Note");
  const safeMeta = escapeHtml(`${note.school || ""}${note.category ? " • "+note.category : ""}${note.grade ? " • grade "+note.grade : ""}`);
  const safeTags = escapeHtml((note.tags || []).join(", "));
  const safeContent = escapeHtml(note.content || "").replace(/\n/g, "<br>");
  w.document.write(`<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>${safeTitle}</title><link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet"><style>body{font-family:Montserrat,system-ui,Segoe UI,Arial;margin:24px;line-height:1.5}h1{margin:0 0 6px}small{color:#555}hr{border:0;border-top:1px solid #ddd;margin:14px 0}.tags{color:#555;font-size:12px;margin-top:6px}</style></head><body><h1>${safeTitle}</h1><small>${safeMeta}</small><div class="tags">${safeTags}</div><hr><div>${safeContent}</div></body></html>`);
  w.document.close();
  w.focus();
  w.print();
}

async function fetchLinks(){
  if(!APP.user){
    APP.links=[];
    return;
  }
  const { data } = await sb.from("note_links").select("note_a,note_b,created_at").limit(1000);
  APP.links = data || [];
}

async function linkNoteFlow(){
  if(!requireUser()) return;
  if(!APP.activeNote){
    toast("Open a note first");
    return;
  }
  const others = APP.notes.filter(n=>n.id!==APP.activeNote.id);
  if(!others.length){
    toast("Need at least 2 notes");
    return;
  }
  const pick = prompt("Type part of the note title to link to:");
  if(!pick) return;
  const p = pick.trim().toLowerCase();
  const found = others.find(n=> (n.title||"").toLowerCase().includes(p));
  if(!found){
    toast("No match");
    return;
  }
  const payload = { user_id: APP.user.id, note_a: APP.activeNote.id, note_b: found.id };
  const { error } = await sb.from("note_links").insert(payload);
  if(error){
    toast("Link failed");
    return;
  }
  await fetchLinks();
  toast("Linked");
}

let graph = null;

function fitCanvas(canvas){
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const w = Math.max(2, Math.floor(rect.width * dpr));
  const h = Math.max(2, Math.floor(rect.height * dpr));
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
  }
  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return { ctx, dpr, cssW: rect.width, cssH: rect.height };
}

function initGraph(){
  const canvas = el("graphCanvas");
  if(!canvas) return;
  const ctx = canvas.getContext("2d");
  const state = { canvas, ctx, nodes:[], edges:[], dragging:null, pan:{x:40,y:40}, zoom:1, last:performance.now() };

  function resize(){
    fitCanvas(canvas);
  }

  function rebuild(){
    const nodes = APP.notes.map((n,i)=>( {
      id:n.id,
      title:(n.title||"(untitled)").slice(0,22),
      x: 260 + Math.cos(i)*140,
      y: 220 + Math.sin(i)*140,
      vx:0, vy:0
    }));
    const idx = new Map(nodes.map((n,i)=>[n.id,i]));
    const edges = [];
    for(const e of APP.links){
      const ia = idx.get(e.note_a);
      const ib = idx.get(e.note_b);
      if(ia==null||ib==null) continue;
      edges.push([ia,ib]);
    }
    state.nodes = nodes;
    state.edges = edges;
  }

  function screenToWorld(mx,my){
    return { x: (mx - state.pan.x)/state.zoom, y: (my - state.pan.y)/state.zoom };
  }

  function pickNode(mx,my){
    const p = screenToWorld(mx,my);
    let best=null, bestD=1e9;
    for(const n of state.nodes){
      const dx=p.x-n.x, dy=p.y-n.y;
      const d=dx*dx+dy*dy;
      if(d<bestD && d<18*18){ best=n; bestD=d; }
    }
    return best;
  }

  function draw(){
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width,rect.height);
    ctx.save();
    ctx.translate(state.pan.x, state.pan.y);
    ctx.scale(state.zoom, state.zoom);

    ctx.lineWidth = 2/state.zoom;
    ctx.strokeStyle = "rgba(255,255,255,.18)";
    for(const [ia,ib] of state.edges){
      const a=state.nodes[ia], b=state.nodes[ib];
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }

    for(const n of state.nodes){
      ctx.beginPath();
      ctx.fillStyle = "rgba(79,140,255,.18)";
      ctx.strokeStyle = "rgba(79,140,255,.55)";
      ctx.arc(n.x,n.y, 16, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "rgba(244,246,251,.92)";
      ctx.font = `${12/state.zoom}px Montserrat, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(n.title, n.x, n.y+18);
    }

    ctx.restore();
  }

  function tick(){
    const now = performance.now();
    const dt = Math.min(0.03, (now - state.last)/1000);
    state.last = now;

    const cx = 520, cy = 320;
    for(const n of state.nodes){
      n.vx += (cx - n.x)*0.012;
      n.vy += (cy - n.y)*0.012;
    }

    for(let i=0;i<state.nodes.length;i++){
      for(let j=i+1;j<state.nodes.length;j++){
        const a=state.nodes[i], b=state.nodes[j];
        const dx=a.x-b.x, dy=a.y-b.y;
        const d2=dx*dx+dy*dy+0.001;
        const f=12000/d2;
        const inv=Math.sqrt(d2);
        a.vx += (dx/inv)*f*dt;
        a.vy += (dy/inv)*f*dt;
        b.vx -= (dx/inv)*f*dt;
        b.vy -= (dy/inv)*f*dt;
      }
    }

    for(const [ia,ib] of state.edges){
      const a=state.nodes[ia], b=state.nodes[ib];
      const dx=b.x-a.x, dy=b.y-a.y;
      const dist=Math.sqrt(dx*dx+dy*dy)+0.001;
      const desired=180;
      const diff=(dist-desired);
      const fx=(dx/dist)*diff*0.020;
      const fy=(dy/dist)*diff*0.020;
      a.vx += fx; a.vy += fy;
      b.vx -= fx; b.vy -= fy;
    }

    for(const n of state.nodes){
      if(state.dragging && state.dragging.id===n.id) continue;
      n.x += n.vx; n.y += n.vy;
      n.vx *= 0.86; n.vy *= 0.86;
    }

    draw();
    requestAnimationFrame(tick);
  }

  canvas.addEventListener("pointerdown", (e)=>{
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;
    const n = pickNode(mx,my);
    if(n){
      state.dragging = { id:n.id };
      canvas.setPointerCapture(e.pointerId);
    }else{
      state.dragging = { pan:true, ox: mx, oy: my, px: state.pan.x, py: state.pan.y };
      canvas.setPointerCapture(e.pointerId);
    }
  });

  canvas.addEventListener("pointermove", (e)=>{
    if(!state.dragging) return;
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    if(state.dragging.pan){
      state.pan.x = state.dragging.px + (mx - state.dragging.ox);
      state.pan.y = state.dragging.py + (my - state.dragging.oy);
      return;
    }

    const node = state.nodes.find(x=>x.id===state.dragging.id);
    if(!node) return;
    const p = screenToWorld(mx,my);
    node.x = p.x; node.y = p.y;
    node.vx = 0; node.vy = 0;
  });

  canvas.addEventListener("pointerup", (e)=>{
    if(!state.dragging) return;
    if(!state.dragging.pan){
      const r = canvas.getBoundingClientRect();
      const mx = e.clientX - r.left;
      const my = e.clientY - r.top;
      const n = pickNode(mx,my);
      if(n) openNote(n.id);
    }
    state.dragging = null;
    canvas.releasePointerCapture(e.pointerId);
  });

  canvas.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;
    const p = screenToWorld(mx,my);
    const factor = e.deltaY > 0 ? 0.92 : 1.08;
    state.zoom = Math.max(0.35, Math.min(2.2, state.zoom*factor));
    state.pan.x = mx - p.x*state.zoom;
    state.pan.y = my - p.y*state.zoom;
  }, { passive:false });

  window.addEventListener("resize", ()=>{ resize(); });

  graph = { resize, rebuild };
  resize();
  rebuild();
  requestAnimationFrame(tick);
}

async function reloadGraph(){
  await fetchLinks();
  if(graph){
    graph.rebuild();
    graph.resize();
  }else{
    initGraph();
  }
  toast("Graph updated");
}

const TRACKS = [
  { key:"A", name:"autumn! - one way (instrumental)", url:"https://cgmazcvmpcgistoimqlw.supabase.co/storage/v1/object/public/assets/autumn!%20-%20one%20way%20(instrumental).mp3" },
  { key:"J", name:"jaydes pluggnb type beat", url:"https://cgmazcvmpcgistoimqlw.supabase.co/storage/v1/object/public/assets/free%20jaydes%20%20pluggnb%20type%20beat%20self%20(1).mp3" },
  { key:"J", name:"jaydes - convenience (instrumental)", url:"https://cgmazcvmpcgistoimqlw.supabase.co/storage/v1/object/public/assets/jaydes%20%20convenience%20(fixed%20instrumental)%20(1).mp3" },
  { key:"M", name:"Me vs Me (instrumental)", url:"https://cgmazcvmpcgistoimqlw.supabase.co/storage/v1/object/public/assets/Me%20vs%20Me%20(Instrumental)%20-%20Jaeychino%20and%20SlimeGetEm%20(1).mp3" },
  { key:"K", name:"Kyle Richh x Sdot Go - Drive me crazy (instrumental)", url:"https://cgmazcvmpcgistoimqlw.supabase.co/storage/v1/object/public/assets/Kyle%20Richh%20x%20Sdot%20Go%20-%20Drive%20me%20crazyOblivious%20(official%20instrumental)%20(1).mp3" },
  { key:"X", name:"ex", url:"https://cgmazcvmpcgistoimqlw.supabase.co/storage/v1/object/public/assets/ex.mp3" },
  { key:"T", name:"jaydes - who can i trust (instrumental)", url:"https://cgmazcvmpcgistoimqlw.supabase.co/storage/v1/object/public/assets/jaydes-who%20can%20i%20trust%20ft.rich%20amiri%20(instrumental).mp3" }
];

function clamp01(n){
  n = Number(n);
  return Number.isFinite(n) ? Math.max(0, Math.min(1, n)) : 0.25;
}

function setupNerdAudio(){
  const sel = el("trackSelect");
  if(sel){
    sel.innerHTML = "";
    for(let i=0;i<TRACKS.length;i++){
      const o = document.createElement("option");
      o.value = String(i);
      o.textContent = TRACKS[i].name;
      sel.appendChild(o);
    }
    sel.value = String(APP.settings.nerd.track || 0);
  }
  const audio = el("bgAudio");
  if(audio){
    audio.loop = true;
    audio.volume = clamp01(APP.settings.nerd.vol);
  }
  const v = el("musicVol");
  if(v) v.value = String(APP.settings.nerd.vol);
}

function setTrack(idx){
  const audio = el("bgAudio");
  if(!audio) return;
  const i = Math.max(0, Math.min(TRACKS.length-1, Number(idx)||0));
  APP.settings.nerd.track = i;
  audio.src = TRACKS[i].url;
}

function stopMusic(){
  const audio = el("bgAudio");
  const btn = el("btnPlayPause");
  if(audio){
    audio.pause();
    audio.currentTime = 0;
  }
  if(btn) btn.textContent = "Play";
}

function playPauseMusic(){
  if(!APP.audioUnlocked){
    toast("Unlock first");
    return;
  }
  const audio = el("bgAudio");
  if(!audio) return;

  if(!audio.src) setTrack(el("trackSelect")?.value ?? 0);

  const btn = el("btnPlayPause");
  if(audio.paused){
    audio.play().then(()=>{
      if(btn) btn.textContent = "Pause";
    }).catch(()=>{
      toast("Tap Play again");
    });
  }else{
    audio.pause();
    if(btn) btn.textContent = "Play";
  }
}

function applyMusicVol(){
  const audio = el("bgAudio");
  const v = clamp01(el("musicVol")?.value ?? 0.25);
  APP.settings.nerd.vol = v;
  if(audio) audio.volume = v;
}

function unlockNerd(){
  const pass = el("nerdPass")?.value ?? "";
  if(pass !== "9999"){
    toast("Wrong password");
    return;
  }
  APP.audioUnlocked = true;
  const panel = el("nerdPanel");
  if(panel) panel.classList.remove("hidden");
  const remember = !!el("rememberUnlock")?.checked;
  if(remember){
    localStorage.setItem("studyos_nerd_unlocked", "1");
  }else{
    localStorage.removeItem("studyos_nerd_unlocked");
  }
  toast("Unlocked");
}

function quickMute(){
  const audio = el("bgAudio");
  if(audio && !audio.paused){
    stopMusic();
    toast("Muted");
  }
}

let audioCtx = null;
function sfx(freq=440, dur=0.07, type="sine", gain=0.05){
  if(!APP.sfxOn) return;
  try{
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(gain, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur);
  }catch(_){}
}

const GAME = {
  mode: "snake",
  running: false,
  last: 0,
  score: 0,
  bestSnake: 0,
  bestTetris: 0,
  snake: null,
  tetris: null
};

function gameCanvas(){ return el("gameCanvas"); }
function snakeSettingsUI(on){
  el("snakeSettings")?.classList.toggle("hidden", !on);
  el("tetrisSettings")?.classList.toggle("hidden", on);
  el("touchControls")?.classList.toggle("hidden", on);
}

function updateGameStats(){
  const st = el("gameStats");
  if(!st) return;
  const best = GAME.mode==="snake" ? GAME.bestSnake : GAME.bestTetris;
  st.textContent = `Score: ${GAME.score}   Best: ${best}`;
}

function resizeGameCanvas(){
  const canvas = gameCanvas();
  if(!canvas) return;
  fitCanvas(canvas);
}

function syncCheatUI(){
  const wrap = el("cheatWrap");
  const slow = el("cheatSlow");
  const mag = el("cheatMagnet");
  if(wrap && GAME.snake) wrap.checked = !!GAME.snake.cheats.wrap;
  if(slow && GAME.snake) slow.checked = !!GAME.snake.cheats.slow;
  if(mag && GAME.snake) mag.checked = !!GAME.snake.cheats.magnet;
}

function initSnake(drawOnly){
  const canvas = gameCanvas();
  if(!canvas) return;
  const { ctx, cssW, cssH } = fitCanvas(canvas);
  const hard = el("snakeHard")?.checked ?? true;

  const size = Math.max(16, Math.min(26, Math.floor(Math.min(cssW/44, cssH/32))));
  const cols = Math.max(18, Math.floor(cssW / size));
  const rows = Math.max(16, Math.floor(cssH / size));

  const randCell = () => ({ x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows) });

  function placeFree(s){
    let tries = 0;
    while(tries++ < 900){
      const p = randCell();
      if(s.body.some(b=>b.x===p.x&&b.y===p.y)) continue;
      if(s.obstacles.some(o=>o.x===p.x&&o.y===p.y)) continue;
      if(s.poison && s.poison.x===p.x && s.poison.y===p.y) continue;
      if(s.food && s.food.x===p.x && s.food.y===p.y) continue;
      return p;
    }
    return randCell();
  }

  const snake = {
    size, cols, rows, ctx, canvas,
    dir:{x:1,y:0},
    nextDir:{x:1,y:0},
    body:[{x:Math.floor(cols/2), y:Math.floor(rows/2)}],
    grow:3,
    food:null,
    poison:null,
    obstacles:[],
    stepAcc:0,
    alive:true,
    hard,
    baseSpeed: hard ? 14 : 10,
    cheats:{wrap:false, slow:false, magnet:false}
  };

  if(hard){
    for(let i=0;i<12;i++){
      const o = placeFree(snake);
      if(Math.abs(o.x-snake.body[0].x)<4 && Math.abs(o.y-snake.body[0].y)<4) continue;
      snake.obstacles.push(o);
    }
  }

  snake.food = placeFree(snake);

  GAME.snake = snake;
  GAME.running = false;
  GAME.score = 0;
  updateGameStats();
  syncCheatUI();

  function draw(){
    const w = cssW, h = cssH;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.fillRect(0,0,w,h);

    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.lineWidth = 1;
    for(let x=0;x<w;x+=snake.size){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<h;y+=snake.size){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }

    const drawCell = (p, fill, glow) => {
      const px = p.x*snake.size;
      const py = p.y*snake.size;
      ctx.fillStyle = fill;
      ctx.fillRect(px+2, py+2, snake.size-4, snake.size-4);
      if(glow){
        ctx.strokeStyle = "rgba(79,140,255,.60)";
        ctx.strokeRect(px+1.5, py+1.5, snake.size-3, snake.size-3);
      }
    };

    for(const o of snake.obstacles) drawCell(o, "rgba(255,255,255,.10)");
    if(snake.poison) drawCell(snake.poison, "rgba(255,77,77,.28)", true);
    drawCell(snake.food, "rgba(79,140,255,.30)", true);

    const inv = performance.now() < APP.invincibleUntil;
    for(let i=snake.body.length-1;i>=0;i--){
      const b = snake.body[i];
      const isHead = i===0;
      drawCell(b, isHead ? (inv ? "rgba(65,217,138,.40)" : "rgba(138,183,255,.30)") : "rgba(79,140,255,.18)", isHead);
    }

    if(!snake.alive){
      ctx.fillStyle = "rgba(0,0,0,.58)";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = "rgba(244,246,251,.95)";
      ctx.font = "700 30px Montserrat, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Game Over", w/2, h/2 - 10);
      ctx.font = "13px Montserrat, sans-serif";
      ctx.fillStyle = "rgba(244,246,251,.72)";
      ctx.fillText("Press Start to try again", w/2, h/2 + 22);
    }else if(!GAME.running){
      ctx.fillStyle = "rgba(0,0,0,.42)";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = "rgba(244,246,251,.92)";
      ctx.font = "700 24px Montserrat, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Press Start", w/2, h/2);
      ctx.font = "12px Montserrat, sans-serif";
      ctx.fillStyle = "rgba(244,246,251,.72)";
      ctx.fillText("or Space / tap canvas", w/2, h/2 + 28);
    }
  }

  function step(dt){
    if(!GAME.running || !snake.alive) return;

    const speed = snake.cheats.slow ? Math.max(7, snake.baseSpeed - 6) : snake.baseSpeed + Math.min(18, Math.floor(GAME.score/4));
    snake.stepAcc += dt * speed;

    if(snake.cheats.magnet){
      const head = snake.body[0];
      const dx = head.x - snake.food.x;
      const dy = head.y - snake.food.y;
      if(Math.abs(dx)+Math.abs(dy) > 2){
        snake.food.x += dx>0 ? 1 : -1;
        snake.food.y += dy>0 ? 1 : -1;
        snake.food.x = (snake.food.x + snake.cols) % snake.cols;
        snake.food.y = (snake.food.y + snake.rows) % snake.rows;
      }
    }

    while(snake.stepAcc >= 1){
      snake.stepAcc -= 1;
      snake.dir = snake.nextDir;

      const head = { ...snake.body[0] };
      head.x += snake.dir.x;
      head.y += snake.dir.y;

      if(snake.cheats.wrap){
        head.x = (head.x + snake.cols) % snake.cols;
        head.y = (head.y + snake.rows) % snake.rows;
      }

      const hitWall = head.x<0 || head.x>=snake.cols || head.y<0 || head.y>=snake.rows;
      const hitSelf = snake.body.some((b,i)=> i>0 && b.x===head.x && b.y===head.y);
      const hitObs = snake.obstacles.some(o=>o.x===head.x && o.y===head.y);
      const inv = performance.now() < APP.invincibleUntil;

      if((hitWall || hitSelf || hitObs) && !inv){
        snake.alive = false;
        GAME.running = false;
        sfx(130, 0.16, "square", 0.08);
        if(GAME.score > GAME.bestSnake) GAME.bestSnake = GAME.score;
        toast("Game over");
        draw();
        updateGameStats();
        return;
      }

      snake.body.unshift(head);

      if(head.x===snake.food.x && head.y===snake.food.y){
        snake.grow += 1;
        GAME.score += 1;
        sfx(700, 0.06, "sine", 0.04);
        if(snake.hard && GAME.score % 3 === 0) snake.obstacles.push(placeFree(snake));
        if(snake.hard && !snake.poison && Math.random() < 0.20) snake.poison = placeFree(snake);
        snake.food = placeFree(snake);
        updateGameStats();
      }

      if(snake.poison && head.x===snake.poison.x && head.y===snake.poison.y){
        snake.poison = null;
        snake.grow = Math.max(0, snake.grow - 2);
        GAME.score = Math.max(0, GAME.score - 2);
        sfx(220, 0.10, "sawtooth", 0.05);
        updateGameStats();
      }

      if(snake.grow>0){
        snake.grow -= 1;
      }else{
        snake.body.pop();
      }
    }

    draw();
  }

  GAME.snake.step = step;
  GAME.snake.draw = draw;
  if(drawOnly) draw();
}

function snakeInput(dx,dy){
  const s = GAME.snake;
  if(!s || !s.alive) return;
  if(dx === -s.dir.x && dy === -s.dir.y) return;
  s.nextDir = { x:dx, y:dy };
}

const TETRIS_PIECES = [
  { k:"I", m:[[1,1,1,1]] },
  { k:"O", m:[[1,1],[1,1]] },
  { k:"T", m:[[0,1,0],[1,1,1]] },
  { k:"S", m:[[0,1,1],[1,1,0]] },
  { k:"Z", m:[[1,1,0],[0,1,1]] },
  { k:"J", m:[[1,0,0],[1,1,1]] },
  { k:"L", m:[[0,0,1],[1,1,1]] }
];

function tetrisCloneMatrix(m){ return m.map(r=>r.slice()); }
function tetrisRotate(m){
  const h = m.length, w = m[0].length;
  const out = Array.from({length:w}, ()=>Array.from({length:h}, ()=>0));
  for(let y=0;y<h;y++) for(let x=0;x<w;x++) out[x][h-1-y] = m[y][x];
  return out;
}

function initTetris(drawOnly){
  const canvas = gameCanvas();
  if(!canvas) return;
  const { ctx, cssW, cssH } = fitCanvas(canvas);

  const t = {
    ctx, canvas,
    w: 10, h: 20,
    board: Array.from({length:20}, ()=>Array.from({length:10}, ()=>0)),
    piece: null,
    next: null,
    x: 3, y: 0,
    fallAcc: 0,
    fallRate: 0.65,
    alive: true,
    lockAcc: 0,
    lockDelay: 0.20,
    didTouchFloor: false
  };

  function randPiece(){
    const p = TETRIS_PIECES[Math.floor(Math.random()*TETRIS_PIECES.length)];
    return { k:p.k, m:tetrisCloneMatrix(p.m) };
  }

  t.next = randPiece();

  function spawn(){
    t.piece = t.next;
    t.next = randPiece();
    t.x = 3;
    t.y = 0;
    t.fallAcc = 0;
    t.lockAcc = 0;
    t.didTouchFloor = false;
    if(collides(t.board, t.piece.m, t.x, t.y)){
      t.alive = false;
      GAME.running = false;
      if(GAME.score > GAME.bestTetris) GAME.bestTetris = GAME.score;
      updateGameStats();
      sfx(120, 0.18, "square", 0.08);
      toast("Tetris over");
      draw();
    }
  }

  function collides(board, m, ox, oy){
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const bx = ox + x;
        const by = oy + y;
        if(bx < 0 || bx >= t.w || by >= t.h) return true;
        if(by >= 0 && board[by][bx]) return true;
      }
    }
    return false;
  }

  function merge(){
    const m = t.piece.m;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const bx = t.x + x;
        const by = t.y + y;
        if(by >= 0 && by < t.h && bx >= 0 && bx < t.w) t.board[by][bx] = 1;
      }
    }
  }

  function clearLines(){
    let cleared = 0;
    for(let y=t.h-1;y>=0;y--){
      let full = true;
      for(let x=0;x<t.w;x++) if(!t.board[y][x]) { full = false; break; }
      if(full){
        t.board.splice(y,1);
        t.board.unshift(Array.from({length:t.w}, ()=>0));
        cleared++;
        y++;
      }
    }
    if(cleared){
      const add = cleared===1 ? 100 : cleared===2 ? 260 : cleared===3 ? 420 : 700;
      GAME.score += add;
      sfx(860, 0.06, "triangle", 0.045);
      updateGameStats();
    }
  }

  function hardDrop(){
    if(!t.alive) return;
    let dy = 0;
    while(!collides(t.board, t.piece.m, t.x, t.y + dy + 1)) dy++;
    t.y += dy;
    lockNow();
    sfx(500, 0.04, "sine", 0.03);
  }

  function lockNow(){
    merge();
    clearLines();
    spawn();
  }

  function move(dx){
    if(!t.alive) return;
    if(!collides(t.board, t.piece.m, t.x + dx, t.y)){
      t.x += dx;
      sfx(420, 0.03, "sine", 0.02);
      t.didTouchFloor = false;
      t.lockAcc = 0;
    }
  }

  function rotate(){
    if(!t.alive) return;
    const r = tetrisRotate(t.piece.m);
    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){
      if(!collides(t.board, r, t.x + k, t.y)){
        t.piece.m = r;
        t.x += k;
        sfx(680, 0.04, "sine", 0.03);
        t.didTouchFloor = false;
        t.lockAcc = 0;
        return;
      }
    }
  }

  function softDrop(){
    if(!t.alive) return;
    if(!collides(t.board, t.piece.m, t.x, t.y + 1)){
      t.y += 1;
      GAME.score += 1;
      updateGameStats();
      return true;
    }
    return false;
  }

  function drawCell(x, y, cell, fill, stroke){
    const px = x*cell;
    const py = y*cell;
    ctx.fillStyle = fill;
    ctx.fillRect(px+1.5, py+1.5, cell-3, cell-3);
    if(stroke){
      ctx.strokeStyle = stroke;
      ctx.strokeRect(px+1.5, py+1.5, cell-3, cell-3);
    }
  }

  function ghostY(){
    let gy = t.y;
    while(!collides(t.board, t.piece.m, t.x, gy + 1)) gy++;
    return gy;
  }

  function draw(){
    const w = cssW, h = cssH;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.fillRect(0,0,w,h);

    const pad = 20;
    const wantPreview = w >= 520;
    const previewW = wantPreview ? Math.min(160, w*0.26) : 0;
    const boardAreaW = w - pad*2 - (wantPreview ? (previewW + 14) : 0);
    const cell = Math.max(12, Math.floor(Math.min(boardAreaW / 10, (h - pad*2) / 20)));
    const boardPxW = cell * 10;
    const boardPxH = cell * 20;
    const bx = pad;
    const by = Math.floor((h - boardPxH) / 2);

    ctx.fillStyle = "rgba(255,255,255,.05)";
    ctx.fillRect(bx-10, by-10, boardPxW+20, boardPxH+20);
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.strokeRect(bx-10.5, by-10.5, boardPxW+21, boardPxH+21);

    ctx.strokeStyle = "rgba(255,255,255,.06)";
    for(let x=0;x<=10;x++){
      ctx.beginPath();
      ctx.moveTo(bx + x*cell, by);
      ctx.lineTo(bx + x*cell, by + boardPxH);
      ctx.stroke();
    }
    for(let y=0;y<=20;y++){
      ctx.beginPath();
      ctx.moveTo(bx, by + y*cell);
      ctx.lineTo(bx + boardPxW, by + y*cell);
      ctx.stroke();
    }

    ctx.save();
    ctx.translate(bx, by);

    for(let y=0;y<t.h;y++){
      for(let x=0;x<t.w;x++){
        if(t.board[y][x]) drawCell(x,y,cell,"rgba(255,255,255,.12)","rgba(255,255,255,.08)");
      }
    }

    if(t.alive && t.piece){
      const showGhost = !!el("tetrisGhost")?.checked;
      const gy = showGhost ? ghostY() : t.y;
      if(showGhost){
        for(let y=0;y<t.piece.m.length;y++){
          for(let x=0;x<t.piece.m[y].length;x++){
            if(!t.piece.m[y][x]) continue;
            const px = t.x + x;
            const py = gy + y;
            if(py < 0) continue;
            drawCell(px, py, cell, "rgba(79,140,255,.10)", "rgba(79,140,255,.20)");
          }
        }
      }

      for(let y=0;y<t.piece.m.length;y++){
        for(let x=0;x<t.piece.m[y].length;x++){
          if(!t.piece.m[y][x]) continue;
          const px = t.x + x;
          const py = t.y + y;
          if(py < 0) continue;
          drawCell(px, py, cell, "rgba(79,140,255,.28)", "rgba(138,183,255,.42)");
        }
      }
    }

    ctx.restore();

    if(wantPreview){
      const px = bx + boardPxW + 18;
      const py = by + 12;
      ctx.fillStyle = "rgba(255,255,255,.05)";
      ctx.fillRect(px, py, previewW, 160);
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.strokeRect(px+0.5, py+0.5, previewW-1, 160-1);

      ctx.fillStyle = "rgba(244,246,251,.86)";
      ctx.font = "700 12px Montserrat, sans-serif";
      ctx.fillText("Next", px + 12, py + 22);

      const nm = t.next?.m || [[1]];
      const scaleCell = Math.floor(Math.min((previewW-24)/4, 18));
      const ox = px + 12;
      const oy = py + 40;
      for(let y=0;y<nm.length;y++){
        for(let x=0;x<nm[y].length;x++){
          if(!nm[y][x]) continue;
          ctx.fillStyle = "rgba(79,140,255,.22)";
          ctx.fillRect(ox + x*scaleCell, oy + y*scaleCell, scaleCell-2, scaleCell-2);
          ctx.strokeStyle = "rgba(138,183,255,.35)";
          ctx.strokeRect(ox + x*scaleCell + .5, oy + y*scaleCell + .5, scaleCell-3, scaleCell-3);
        }
      }

      ctx.fillStyle = "rgba(244,246,251,.70)";
      ctx.font = "12px Montserrat, sans-serif";
      ctx.fillText("Score", px + 12, py + 118);
      ctx.font = "700 18px Montserrat, sans-serif";
      ctx.fillText(String(GAME.score), px + 12, py + 144);
    }

    if(!t.alive){
      ctx.fillStyle = "rgba(0,0,0,.58)";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = "rgba(244,246,251,.95)";
      ctx.font = "700 30px Montserrat, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Game Over", w/2, h/2 - 10);
      ctx.font = "13px Montserrat, sans-serif";
      ctx.fillStyle = "rgba(244,246,251,.72)";
      ctx.fillText("Press Start to try again", w/2, h/2 + 22);
    }else if(!GAME.running){
      ctx.fillStyle = "rgba(0,0,0,.42)";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = "rgba(244,246,251,.92)";
      ctx.font = "700 24px Montserrat, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Press Start", w/2, h/2);
      ctx.font = "12px Montserrat, sans-serif";
      ctx.fillStyle = "rgba(244,246,251,.72)";
      ctx.fillText("Arrows to move • Up/W rotate • Space drop", w/2, h/2 + 28);
    }
  }

  function step(dt){
    if(!GAME.running || !t.alive) return;

    const rate = Math.max(0.10, t.fallRate - Math.min(0.50, Math.floor(GAME.score/800) * 0.06));
    t.fallAcc += dt;

    while(t.fallAcc >= rate){
      t.fallAcc -= rate;

      if(!collides(t.board, t.piece.m, t.x, t.y + 1)){
        t.y += 1;
        t.didTouchFloor = false;
        t.lockAcc = 0;
      }else{
        const lockOn = !!el("tetrisLock")?.checked;
        if(!lockOn){
          lockNow();
          sfx(300, 0.05, "sine", 0.03);
          break;
        }
        t.didTouchFloor = true;
      }
    }

    if(t.didTouchFloor){
      t.lockAcc += dt;
      if(t.lockAcc >= t.lockDelay){
        lockNow();
        sfx(300, 0.05, "sine", 0.03);
      }
    }

    draw();
  }

  GAME.tetris = {
    step,
    draw,
    move,
    rotate,
    softDrop,
    hardDrop,
    reset: ()=>{
      t.board = Array.from({length:20}, ()=>Array.from({length:10}, ()=>0));
      t.alive = true;
      t.next = randPiece();
      spawn();
      draw();
    }
  };

  GAME.running = false;
  GAME.score = 0;
  updateGameStats();
  spawn();
  if(drawOnly) draw();
}

function setGameMode(m){
  GAME.mode = m;
  if(el("gameTitle")) el("gameTitle").textContent = m==="snake" ? "Snake" : "Tetris";
  if(el("gameHint")){
    el("gameHint").textContent = m==="snake"
      ? "Arrow keys / WASD. Tap to turn. Space to restart."
      : "Arrows to move. Up/W rotate. Space drops. Tap rotates (mobile).";
  }
  snakeSettingsUI(m==="snake");
  resizeGameCanvas();
  if(m==="snake") initSnake(true); else initTetris(true);
  updateGameStats();
}

function startGame(){
  if(GAME.mode==="snake"){
    if(!GAME.snake) initSnake(true);
    if(!GAME.snake.alive) initSnake(true);
    GAME.running = true;
    sfx(440, 0.05, "sine", 0.03);
  }else{
    if(!GAME.tetris) initTetris(true);
    GAME.running = true;
    sfx(440, 0.05, "sine", 0.03);
  }
}

function resetGame(){
  GAME.running = false;
  if(GAME.mode==="snake") initSnake(true);
  else{
    GAME.score = 0;
    updateGameStats();
    initTetris(true);
  }
}

function gameLoop(t){
  const dt = GAME.last ? Math.min(0.05, (t - GAME.last)/1000) : 0;
  GAME.last = t;
  if(GAME.mode==="snake" && GAME.snake) GAME.snake.step(dt);
  if(GAME.mode==="tetris" && GAME.tetris) GAME.tetris.step(dt);
  requestAnimationFrame(gameLoop);
}

function activateInvincible(){
  APP.invincibleUntil = performance.now() + 10000;
  toast("Invincible 10s");
  sfx(880, 0.08, "triangle", 0.04);
}

function clearObstacles(){
  if(GAME.snake){
    GAME.snake.obstacles = [];
    GAME.snake.poison = null;
    toast("Cleared obstacles");
    if(GAME.snake.draw) GAME.snake.draw();
  }
}

function addLength(){
  if(GAME.snake){
    GAME.snake.grow += 5;
    toast("+5 length");
  }
}

let timer = { mode:"focus", running:false, remaining: 1500, last:0, focus:25*60, brk:5*60 };

function timerRender(){
  const m = Math.floor(timer.remaining/60);
  const s = Math.floor(timer.remaining%60);
  if(el("timerDisplay")) el("timerDisplay").textContent = `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  if(el("timerState")) el("timerState").textContent = timer.running ? (timer.mode==="focus" ? "Focusing" : "Break") : "Ready";
}

function timerSetFromInputs(){
  const f = Number(el("focusMins")?.value ?? 25);
  const b = Number(el("breakMins")?.value ?? 5);
  timer.focus = (Number.isFinite(f) && f>0 && f<600) ? Math.round(f*60) : 1500;
  timer.brk = (Number.isFinite(b) && b>0 && b<120) ? Math.round(b*60) : 300;
  if(!timer.running){
    timer.remaining = timer.mode==="focus" ? timer.focus : timer.brk;
    timerRender();
  }
}

function timerStart(){
  timerSetFromInputs();
  timer.running = true;
  timer.last = performance.now();
  sfx(520, 0.04, "triangle", 0.03);
}

function timerPause(){
  timer.running = false;
  sfx(260, 0.04, "triangle", 0.03);
}

function timerReset(){
  timer.running = false;
  timer.mode = "focus";
  timer.remaining = timer.focus;
  timerRender();
}

function timerTick(){
  const now = performance.now();
  if(timer.running){
    const dt = (now - timer.last)/1000;
    timer.last = now;
    timer.remaining -= dt;
    if(timer.remaining <= 0){
      timer.mode = (timer.mode==="focus") ? "break" : "focus";
      timer.remaining = timer.mode==="focus" ? timer.focus : timer.brk;
      sfx(880, 0.10, "sine", 0.05);
      toast(timer.mode==="focus" ? "Back to focus" : "Break time");
    }
    timerRender();
  }
  requestAnimationFrame(timerTick);
}

function showTab(name){
  qsa(".navbtn").forEach(b=>b.classList.toggle("active", b.dataset.tab===name));
  const panels = ["notes","graph","games","timer","settings"];
  for(const p of panels){
    const sec = el(`tab-${p}`);
    if(sec) sec.classList.toggle("hidden", p!==name);
  }
  if(el("panelTitle")) el("panelTitle").textContent = name.charAt(0).toUpperCase()+name.slice(1);
  if(name==="graph") reloadGraph();
  if(name==="games"){
    resizeGameCanvas();
    if(GAME.mode==="snake" && GAME.snake?.draw) GAME.snake.draw();
    if(GAME.mode==="tetris" && GAME.tetris?.draw) GAME.tetris.draw();
  }
}

function openAuthModal(open){
  const m = el("authModal");
  if(m) m.classList.toggle("hidden", !open);
  const msg = el("authMsg");
  if(msg) msg.textContent = "—";
}

async function signIn(){
  const email = el("authEmail")?.value?.trim() || "";
  const password = el("authPass")?.value || "";
  if(el("authMsg")) el("authMsg").textContent = "Signing in...";
  const { data, error } = await sb.auth.signInWithPassword({ email, password });
  if(error){
    if(el("authMsg")) el("authMsg").textContent = error.message;
    return;
  }
  if(data?.user){
    if(el("authMsg")) el("authMsg").textContent = "Signed in";
    openAuthModal(false);
  }
}

async function signUp(){
  const email = el("authEmail")?.value?.trim() || "";
  const password = el("authPass")?.value || "";
  if(el("authMsg")) el("authMsg").textContent = "Signing up...";
  const { data, error } = await sb.auth.signUp({ email, password });
  if(error){
    if(el("authMsg")) el("authMsg").textContent = error.message;
    return;
  }
  if(data?.session){
    if(el("authMsg")) el("authMsg").textContent = "Account created and signed in";
    openAuthModal(false);
  }else{
    if(el("authMsg")) el("authMsg").textContent = "Account created. Check email to confirm (if enabled).";
  }
}

async function logout(){
  await sb.auth.signOut();
  toast("Logged out");
}

function bindUI(){
  qsa(".navbtn").forEach(b=> b.addEventListener("click", ()=> showTab(b.dataset.tab)));

  el("btnOpenAuth")?.addEventListener("click", ()=> openAuthModal(true));
  el("btnCloseAuth")?.addEventListener("click", ()=> openAuthModal(false));
  el("btnSignIn")?.addEventListener("click", signIn);
  el("btnSignUp")?.addEventListener("click", signUp);
  el("btnLogout")?.addEventListener("click", logout);

  el("btnNewNote")?.addEventListener("click", createNote);
  el("btnSaveNow")?.addEventListener("click", saveNow);
  el("btnDelete")?.addEventListener("click", deleteNote);
  el("btnPrint")?.addEventListener("click", printActive);
  el("btnLink")?.addEventListener("click", linkNoteFlow);

  el("noteSearch")?.addEventListener("input", renderNotesList);
  el("filterSchool")?.addEventListener("change", renderNotesList);
  el("filterCategory")?.addEventListener("change", renderNotesList);

  ["noteTitle","noteSchool","noteCategory","noteGrade","noteTags","noteContent"].forEach(id=>{
    el(id)?.addEventListener("input", ()=>{
      if(!APP.activeNote) return;
      setSaveState("Typing...");
      scheduleAutosave();
    });
  });

  el("btnSaveSettings")?.addEventListener("click", saveSettings);

  el("nerdUnlock")?.addEventListener("click", unlockNerd);
  el("btnPlayPause")?.addEventListener("click", playPauseMusic);
  el("btnStop")?.addEventListener("click", stopMusic);
  el("musicVol")?.addEventListener("input", applyMusicVol);
  el("trackSelect")?.addEventListener("change", (e)=> setTrack(e.target.value));

  el("rememberUnlock")?.addEventListener("change", (e)=>{
    const on = !!e.target.checked;
    if(on) localStorage.setItem("studyos_nerd_unlocked","1");
    else localStorage.removeItem("studyos_nerd_unlocked");
  });

  el("sfxEnabled")?.addEventListener("change", (e)=>{ APP.sfxOn = !!e.target.checked; });
  el("snakeHard")?.addEventListener("change", ()=>{ if(GAME.mode==="snake") initSnake(true); });

  el("cheatWrap")?.addEventListener("change", (e)=>{ if(GAME.snake) GAME.snake.cheats.wrap = !!e.target.checked; });
  el("cheatSlow")?.addEventListener("change", (e)=>{ if(GAME.snake) GAME.snake.cheats.slow = !!e.target.checked; });
  el("cheatMagnet")?.addEventListener("change", (e)=>{ if(GAME.snake) GAME.snake.cheats.magnet = !!e.target.checked; });

  el("btnInvincible")?.addEventListener("click", activateInvincible);
  el("btnClearObs")?.addEventListener("click", clearObstacles);
  el("btnAdd5")?.addEventListener("click", addLength);

  el("btnGameSnake")?.addEventListener("click", ()=> setGameMode("snake"));
  el("btnGameTetris")?.addEventListener("click", ()=> setGameMode("tetris"));
  el("btnGameStart")?.addEventListener("click", startGame);
  el("btnGameReset")?.addEventListener("click", resetGame);

  el("touchLeft")?.addEventListener("click", ()=> GAME.tetris?.move?.(-1));
  el("touchRight")?.addEventListener("click", ()=> GAME.tetris?.move?.(1));
  el("touchRotate")?.addEventListener("click", ()=> GAME.tetris?.rotate?.());
  el("touchDown")?.addEventListener("click", ()=> GAME.tetris?.softDrop?.());
  el("touchDrop")?.addEventListener("click", ()=> GAME.tetris?.hardDrop?.());

  el("btnReloadGraph")?.addEventListener("click", reloadGraph);

  el("btnTimerStart")?.addEventListener("click", timerStart);
  el("btnTimerPause")?.addEventListener("click", timerPause);
  el("btnTimerReset")?.addEventListener("click", timerReset);
  el("focusMins")?.addEventListener("input", timerSetFromInputs);
  el("breakMins")?.addEventListener("input", timerSetFromInputs);

  const gc = el("gameCanvas");
  if(gc){
    let touch = null;

    gc.addEventListener("pointerdown", (e)=>{
      if(GAME.mode==="snake"){
        if(!GAME.running) startGame();
        return;
      }
      const r = gc.getBoundingClientRect();
      touch = { x:e.clientX - r.left, y:e.clientY - r.top, t:performance.now() };
      if(!GAME.running) startGame();
    });

    gc.addEventListener("pointerup", (e)=>{
      if(GAME.mode==="snake") return;
      if(!touch) return;
      const r = gc.getBoundingClientRect();
      const x = e.clientX - r.left;
      const y = e.clientY - r.top;
      const dx = x - touch.x;
      const dy = y - touch.y;
      const adx = Math.abs(dx);
      const ady = Math.abs(dy);
      const isTap = adx < 14 && ady < 14 && (performance.now() - touch.t) < 260;
      if(isTap){
        GAME.tetris?.rotate?.();
        touch = null;
        return;
      }
      if(adx > ady){
        if(dx < 0) GAME.tetris?.move?.(-1);
        else GAME.tetris?.move?.(1);
      }else{
        if(dy > 0){
          if(ady > 80) GAME.tetris?.hardDrop?.();
          else GAME.tetris?.softDrop?.();
        }
      }
      touch = null;
    });
  }

  window.addEventListener("resize", ()=>{
    resizeGameCanvas();
    if(GAME.mode==="snake" && GAME.snake?.draw) GAME.snake.draw();
    if(GAME.mode==="tetris" && GAME.tetris?.draw) GAME.tetris.draw();
  });

  window.addEventListener("keydown", (e)=>{
    if(e.key === "`"){ quickMute(); return; }
    if(e.key.toLowerCase() === "n" && !e.ctrlKey && !e.metaKey && !e.altKey){
      if(document.activeElement && ["INPUT","TEXTAREA","SELECT"].includes(document.activeElement.tagName)) return;
      createNote();
      return;
    }
    if(e.key === "Escape"){ openAuthModal(false); return; }

    if(GAME.mode==="snake"){
      const k = e.key.toLowerCase();
      if(k==="arrowup"||k==="w") snakeInput(0,-1);
      if(k==="arrowdown"||k==="s") snakeInput(0,1);
      if(k==="arrowleft"||k==="a") snakeInput(-1,0);
      if(k==="arrowright"||k==="d") snakeInput(1,0);
      if(k===" " && !GAME.running) startGame();
    }else{
      const k = e.key.toLowerCase();
      if(k==="arrowleft"||k==="a") GAME.tetris?.move?.(-1);
      if(k==="arrowright"||k==="d") GAME.tetris?.move?.(1);
      if(k==="arrowdown"||k==="s") GAME.tetris?.softDrop?.();
      if(k==="arrowup"||k==="w") GAME.tetris?.rotate?.();
      if(k===" "){
        if(!GAME.running) startGame();
        GAME.tetris?.hardDrop?.();
      }
    }
  });
}

async function boot(){
  bindUI();
  setupNerdAudio();
  timerRender();
  timerTick();
  requestAnimationFrame(gameLoop);

  const remembered = localStorage.getItem("studyos_nerd_unlocked")==="1";
  if(remembered){
    if(el("rememberUnlock")) el("rememberUnlock").checked = true;
    APP.audioUnlocked = true;
    if(el("nerdPanel")) el("nerdPanel").classList.remove("hidden");
  }

  const { data } = await sb.auth.getSession();
  APP.user = data?.session?.user || null;
  setAuthedUI();

  if(APP.user){
    await ensureSettingsRow();
    await loadSettings();
    await fetchNotes();
    await fetchLinks();
  }else{
    setEditorEnabled(false);
    renderNotesList();
  }

  sb.auth.onAuthStateChange(async (_event, session)=>{
    APP.user = session?.user || null;
    setAuthedUI();
    fillEditor(null);
    renderNotesList();
    if(APP.user){
      await ensureSettingsRow();
      await loadSettings();
      await fetchNotes();
      await fetchLinks();
    }
  });

  initGraph();
  setGameMode("snake");
  showTab("notes");
}

boot();
</script>
</body>
</html>

